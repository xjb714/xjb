
//code generated by deepseek v3.2

#include <iostream>
#include <string>
#include <cstring>

#ifdef _WIN32
    // Windows
    #include <windows.h>
    #include <intrin.h>
    
    // 检查是否为 ARM 架构
    #if defined(_M_ARM) || defined(_M_ARM64) || defined(__arm__) || defined(__aarch64__)
        #define IS_ARM 1
    #else
        #define IS_ARM 0
    #endif
#else
    // Linux/macOS
    #include <unistd.h>
    #include <fstream>
    
    // 检查架构
    #if defined(__arm__) || defined(__aarch64__) || defined(__ARM_ARCH)
        #define IS_ARM 1
    #else
        #define IS_ARM 0
    #endif
#endif

// 跨平台获取 CPU 名称的函数
std::string getCPUName() {
    std::string cpuName = "Unknown CPU";
    
    #ifdef _WIN32
        // Windows 平台
        if (!IS_ARM) {
            // x86/x64 - 使用 CPUID 指令
            int cpuInfo[4] = {-1};
            char cpuBrand[0x40] = {0};
            
            // 检查是否支持扩展 CPUID 功能 (0x80000000 及以上)
            __cpuid(cpuInfo, 0x80000000);
            unsigned int nExIds = cpuInfo[0];
            
            if (nExIds >= 0x80000004) {
                // 获取 CPU 品牌字符串 (0x80000002, 0x80000003, 0x80000004)
                for (int i = 0; i < 3; ++i) {
                    __cpuid(cpuInfo, 0x80000002 + i);
                    memcpy(cpuBrand + i * 16, cpuInfo, 16);
                }
                cpuName = cpuBrand;
            }
        } else {
            // ARM Windows - 使用注册表
            HKEY hKey;
            DWORD type, size = 0;
            char name[256] = {0};
            
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
                           0, KEY_READ, &hKey) == ERROR_SUCCESS) {
                if (RegQueryValueEx(hKey, "ProcessorNameString", nullptr, &type,
                                  nullptr, &size) == ERROR_SUCCESS && size > 0) {
                    RegQueryValueEx(hKey, "ProcessorNameString", nullptr, &type,
                                  (LPBYTE)name, &size);
                    cpuName = name;
                }
                RegCloseKey(hKey);
            }
        }
    #else
        // Linux/macOS/Unix 平台
        if (!IS_ARM) {
            // x86/x64 - 读取 /proc/cpuinfo 或使用 CPUID
            #ifdef __linux__
                std::ifstream cpuinfo("/proc/cpuinfo");
                std::string line;
                while (std::getline(cpuinfo, line)) {
                    if (line.find("model name") != std::string::npos) {
                        size_t colonPos = line.find(':');
                        if (colonPos != std::string::npos) {
                            cpuName = line.substr(colonPos + 2);
                            break;
                        }
                    }
                }
                cpuinfo.close();
            #elif defined(__APPLE__)
                // macOS x86
                FILE* pipe = popen("sysctl -n machdep.cpu.brand_string", "r");
                if (pipe) {
                    char buffer[256];
                    if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                        cpuName = buffer;
                    }
                    pclose(pipe);
                }
            #else
                // 其他 Unix 系统
                #if defined(__x86_64__) || defined(__i386__)
                    // 内联汇编实现 CPUID
                    char brand[0x40] = {0};
                    unsigned int *brandAsInts = reinterpret_cast<unsigned int*>(brand);
                    
                    // 检查扩展 CPUID 支持
                    unsigned int eax, ebx, ecx, edx;
                    asm volatile("cpuid" : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                                 : "a"(0x80000000));
                    
                    if (eax >= 0x80000004) {
                        // 获取品牌字符串
                        for (int i = 0; i < 3; ++i) {
                            asm volatile("cpuid" 
                                       : "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
                                       : "a"(0x80000002 + i));
                            brandAsInts[i*4 + 0] = eax;
                            brandAsInts[i*4 + 1] = ebx;
                            brandAsInts[i*4 + 2] = ecx;
                            brandAsInts[i*4 + 3] = edx;
                        }
                        cpuName = brand;
                    }
                #endif
            #endif
        } else {
            // ARM Linux/macOS
            #ifdef __linux__
                // Linux ARM - 读取 /proc/cpuinfo
                std::ifstream cpuinfo("/proc/cpuinfo");
                std::string line;
                
                // ARM Linux 可能有不同的字段名
                const char* fieldNames[] = {
                    "model name",     // 一些 ARM 架构使用
                    "Processor",      // ARM 传统字段
                    "Hardware",       // 一些 ARM 板卡使用
                    "CPU part",       // 显示 CPU 型号
                    "CPU implementer" // 显示 CPU 制造商
                };
                
                for (const auto& field : fieldNames) {
                    cpuinfo.clear();
                    cpuinfo.seekg(0);
                    
                    while (std::getline(cpuinfo, line)) {
                        if (line.find(field) != std::string::npos) {
                            size_t colonPos = line.find(':');
                            if (colonPos != std::string::npos) {
                                std::string value = line.substr(colonPos + 2);
                                
                                // 如果获取到有效值，尝试解码
                                if (!value.empty() && value != "(null)") {
                                    cpuName = value;
                                    
                                    // 如果是 CPU implementer，可以转换为可读名称
                                    if (strcmp(field, "CPU implementer") == 0) {
                                        if (cpuName.find("0x41") != std::string::npos)
                                            cpuName = "ARM Limited";
                                        else if (cpuName.find("0x42") != std::string::npos)
                                            cpuName = "Broadcom";
                                        else if (cpuName.find("0x43") != std::string::npos)
                                            cpuName = "Cavium";
                                        else if (cpuName.find("0x44") != std::string::npos)
                                            cpuName = "DEC";
                                        else if (cpuName.find("0x51") != std::string::npos)
                                            cpuName = "Qualcomm";
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (cpuName != "Unknown CPU") break;
                }
                
                cpuinfo.close();
                
                // 如果仍然未知，尝试使用 lscpu 命令
                if (cpuName == "Unknown CPU") {
                    FILE* pipe = popen("lscpu | grep 'Model name'", "r");
                    if (pipe) {
                        char buffer[256];
                        if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                            std::string line(buffer);
                            size_t colonPos = line.find(':');
                            if (colonPos != std::string::npos) {
                                cpuName = line.substr(colonPos + 2);
                            }
                        }
                        pclose(pipe);
                    }
                }
            #elif defined(__APPLE__)
                // macOS ARM (Apple Silicon)
                FILE* pipe = popen("sysctl -n machdep.cpu.brand_string", "r");
                if (!pipe) {
                    pipe = popen("sysctl -n hw.model", "r");
                }
                
                if (pipe) {
                    char buffer[256];
                    if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                        cpuName = buffer;
                    }
                    pclose(pipe);
                }
            #endif
        }
    #endif
    
    // 清理字符串 - 去除前后空白字符
    size_t start = cpuName.find_first_not_of(" \t\n\r");
    size_t end = cpuName.find_last_not_of(" \t\n\r");
    
    if (start != std::string::npos && end != std::string::npos) {
        cpuName = cpuName.substr(start, end - start + 1);
    }
    
    return cpuName;
}

// 辅助函数：获取架构信息
std::string getArchitecture() {
    std::string arch;
    
    #ifdef _WIN32
        #if defined(_M_AMD64) || defined(__x86_64__)
            arch = "x64";
        #elif defined(_M_IX86) || defined(__i386__)
            arch = "x86";
        #elif defined(_M_ARM64) || defined(__aarch64__)
            arch = "ARM64";
        #elif defined(_M_ARM) || defined(__arm__)
            arch = "ARM";
        #else
            arch = "Unknown";
        #endif
    #else
        #if defined(__x86_64__)
            arch = "x86_64";
        #elif defined(__i386__)
            arch = "x86";
        #elif defined(__aarch64__)
            arch = "ARM64";
        #elif defined(__arm__)
            arch = "ARM";
        #elif defined(__powerpc__)
            arch = "PowerPC";
        #else
            arch = "Unknown";
        #endif
    #endif
    
    return arch;
}

// int main() {
//     std::string cpuName = getCPUName();
//     std::string arch = getArchitecture();
    
//     std::cout << "CPU 名称: " << cpuName << std::endl;
//     std::cout << "架构: " << arch << std::endl;
    
//     return 0;
// }

// int main() {
//     std::string cpuName = getCPUName();
//     std::cout << "CPU名称: " << cpuName << std::endl;
//     return 0;
// }